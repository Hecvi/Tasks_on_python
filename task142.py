# Штаб гражданской обороны Тридесятой области решил обновить план спасения на
# случай ядерной атаки. Известно, что все n селений Тридесятой области
# находятся вдоль одной прямой дороги. Вдоль дороги также расположены m
# бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
# необходимо для каждого селения определить ближайшее к нему бомбоубежище
# В первой строке вводится число n - количество селений (1 <= n <= 100000).
# Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
# расстояние от начала дороги до i-го селения. В третьей строке входных данных
# задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая
# строка содержит m различных целых чисел, i-е из этих чисел задает расстояние
# от начала дороги до i-го бомбоубежища. Все расстояния положительны и не
# превышают 10⁹. Селение и убежище могут располагаться в одной точке. Выведите
# n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища.
# Бомбоубежища пронумерованы от 1 до m в том порядке, в котором они заданы во
# входных данных. Создайте список кортежей из пар (позиция селения,
# его номер в исходном списке), а также аналогичный список для бомбоубежищ.
# Отсортируйте эти списки. Перебирайте селения в порядке возрастания.
# Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо
# выбрать ближайшее. При переходе к следующему селению не обязательно искать
# ближайшее бомбоубежище с самого начала. Его можно искать начиная с позиции,
# найденной для предыдущего города. Аналогично, не нужно искать подходящее
# бомбоубежище до конца списка бомбоубежищ: достаточно найти самое близкое.
# Если Вы неэффективно реализуете эту часть, то решение тесты не пройдет
# Для хранения ответа используйте список, где индекс будет номером селения, а
# по этому индексу будет запоминаться номер бомбоубежища


num_of_cities = int(input())
s_from_start_to_city = list(map(int, input().split()))
num_of_shelters = int(input())
s_from_start_to_shelter = list(map(int, input().split()))
list_cities = []
list_shelts = []
for i in range(num_of_cities):
    city = tuple([s_from_start_to_city[i], i + 1])
    list_cities.append(city)
for i in range(num_of_shelters):
    shelter = tuple([s_from_start_to_shelter[i], i + 1])
    list_shelts.append(shelter)
list_cities.sort()
list_shelts.sort()
final = []
start = 1
for i in range(num_of_cities):
    if num_of_shelters == 0:
        final.append(tuple([list_cities[i][1], 0]))
    if num_of_shelters == 1:
        final.append(tuple([list_cities[i][1], 1]))
    else:
        for j in range(start, num_of_shelters):
            next = abs(list_shelts[j][0] - list_cities[i][0])
            prev = abs(list_shelts[j - 1][0] - list_cities[i][0])
            if next > prev:
                final.append(tuple([list_cities[i][1], list_shelts[j - 1][1]]))
                start = j
                break
            if j + 1 == num_of_shelters:
                final.append(tuple([list_cities[i][1], list_shelts[j][1]]))
final.sort()
for i in range(num_of_cities):
    print(final[i][1], end=' ')
